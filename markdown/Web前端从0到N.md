# Web前端从0到N

如何 `从程序员成长为技术经理`

在我加入公司前(2016年初), 软件研发部门的技术栈围绕 Java 6 展开.

我以技术经理的职位加入公司, 主要职责有2个

* 组建Web前端部门
* 让Web前端部门的工作走上正轨

### 第一次技术升级

刚开始, 有点无处着手.
研发中心的编制中甚至没有web前端部门, 仅有的几名网页开发同事都归属于设计部.

第一次的技术升级, 主要解决两个问题

1. 需要一个团队
2. 解决手头积压的工作

#### 先来解决第一个问题, 团队问题

创建一个小部门, 需要领导支持.
这一点很重要, 公司流程中很多琐事如果领导不支持根本无法推进.

第一步

在行政上划分出新部门: Web前端.
(当然这是CEO操作的, 我只是等待审核结果)

第二步

把设计部里几名网页开发转到Web前端部门下.

有了部门, 有了人. 紧接着的问题是: 老兵遇上新领导, 怎么管理.
我的经验: 最好的方法是"真诚"

#### 再解决技术难题

先填坑

公司3年多积累下来的前端代码

前后6名前端 + 20多Java + 3名PHP 参与过Web前端代码编写或维护.

三个字形容: `乱` `散` `杂`

原来的服务采用单体服务, 前端页面由后端(JSP/PHP)代码渲染生成.
甚至有通过CMS后台手工录入HTML片段, 再通过数据读接口取出来渲染到页面当中.

`剪不断理还乱...别是一番滋味在心头`

**解决方法**

1. 刷存在感
    
    首先要解决的是, 让研发同事习惯Web前端部门的存在.

2. 制定Web前端工作流程

    独立Web前端, 不再是 设计/后端 的附庸. 有独立的工作流程和代码控制权

先说说刷存在感的事情, 为什么重要. 为什么重要呢, 就不多说了. 总之很重要.

Web前端想要独立, 关键在于代码的控制权. 软件开发过程中, 代码就是一切.

旧开发流程给 产品经理/后台开发/测试团队 的固定印象:

* 前端就是做网页
* 做网页就是切图

由此导致了开发流程的模式是

> 产品原型 -> UI -> 切图 -> 后端开发 -> 提交测试

前端需要改变, 从创建自己的代码库开始!

1. 向CTO提出, Web前端需要自己的代码库 [CTO同意]
2. 询问后端同事, 代码库的地址以及代码库的管理员 [指向运维]
3. 向运维申请新代码库权限 [邮件回复了SVN的地址和新账号]
4. 犹豫了一秒钟, 然后删掉了SVN地址和账号 [抵制SVN]
5. 向运维申请服务器 (被问: 前端要服务器做啥?) [得到一台独立虚拟服务器资源]
6. 搭建Gitlab服务
7. 创建代码库, 向Web前端部门同事分发gitlab账号
8. 技术分享讲座, 向Web前端部门内的同事推广git [强制使用]

... 遇到了一些变故, 有好有坏, 经过了长时间的磨合后

9. 与安卓团队的gitlab服务合并
10. 引入CI工具, 集成jenkins与gitlab, 自动编译并发布到测试环境
11. 修改web项目的开发流程, 缩短Web前端的开发周期

这一过程持续了很长时间(9个多月), 当中也遇到了很多问题, 比如

* 向运维申请服务器资源的时候, 被问到: 前端要服务器有什么用? (前端对运维来说毫无存在感)
* git的推广难度, 对于传统的网页开发人员来说, git过于复杂, 难以操作
* Web前端和后端的耦合度依然过高, 想要进一步解耦需要对前端做大幅度的重构
* 产品经理/测试团队 的工作方式难以改变

针对以上问题, 解决问题需要的工作方式是:

* 先清理积压工作, 不要让自己陷入到处救火的尴尬. 腾出时间才能更好的思考新架构
* 申请硬件资源, 有前端自己的服务器资源, 搭建辅助开发的服务
* 多次的技术分享(刷存在感), 以前端技术为主, 听众不局限部门内同事
* 前后端代码拆分, 独立出Web前端的代码, 掌握代码的主动权(刷存在感)
* 说服其它部门的同事, 新的前端开发流程更优秀(刷存在感)
* 职场中不妄图以理服人, 很多资源是靠吵架争取来的...(强刷存在感)

### 第二次技术升级

有了人, 有了资源, 那么就要准备干事了.

这次的目标是 `要从本质上推动Web前端的技术变革.`

结合具体情况, 引入了新工具

**React** 和 **Gulp**

新工具引入过程中的技术选型, 主要对比考量的是:

* Angular vs. React(胜)

    Angular还只是1.0版本, 体验之后觉得不行, 不够好用

* Vue vs. React(胜)

    那个时候的vue, 尚未引人注意, vue甚至不再考虑范围之内

* Grunt vs. Gulp(胜)

    Grunt基于配置, Gulp基于代码, 我喜欢更灵活的Gulp

* Webpack vs. Browserify vs. gulp-*(胜)

    webpack入门的门槛太高, Browserify的功能可以被 gulp-* 插件代替

这一阶段的技术选型的重点是团队整体的技能水平和学习能力. 求稳不求快. 

实际上, 在这个阶段也出现掉队的情况. 对于技术能力跟不上的同事.
不勉强保留岗位, 更不能为了迁就个别同事而放弃对前端的技术改进.

在这一转变过程中, 考验的是技术经理的综合能力, 怎样才能稳稳的推进技术变革.

* 团队 - 招聘, 通过招聘建设一个梯队型的团队(全精英团队不现实), 看重掌握新技术的能力.
* 团队 - 优化, 给所有人锻炼新技能的机会. 实在跟不上, 也不勉强保留开发人员名额.
* 任务分配 - 轮岗, 交叉工作内容. 让所有人熟悉所有项目, 掌握每个项目的开发能力.
* 任务分配 - 难度适配, 困难任务给高手, 简单任务给新手. 保证任务进度情况下, 给以适当的锻炼 
* 开发辅助 - 统一开发模式, 要创建一套 完整的/可配置的/易用的/服务化的 开发环境
* 开发辅助 - 统一开发命令, 对Gulp的 CLI 进行再包装, 统一所有项目开发时的命令格式(长期收益会很高)

### 第三次技术升级

一个艰难而冒险的决定

引入 **Webpack**

对Web前端的再次技术改造, 目标是做出一个 全面的/完整的 最佳实践方案.

引入 **webpack** 框架, 需要冒着相当大的风险. 那时感觉自己在"玩火",
是 "玩火自焚" 还是变成 "指路明灯" 并不是很有把握.

但是, 程序员都不甘平凡!

引入 webpack 同时, 对现有的技术栈作了调整, 最终的组合是

> Gulp + Webpack + React + Mobx

新技术栈风险

1. Webpack的引入能否兼容原有的开发模式
2. 基于webpack, 引入了ES6的语法, 需要开发人员学习新语法
3. Mobx作为数据层, 改变了原来的数据使用方式
4. 因为部门内部采用了轮岗机制, 新技术栈, 要求所有前端都必须掌握

现在来看, 结果比较乐观. 总结一下针对以上问题的解决方法是

1. 在gulp和webpack的命令基础上封装一层简单的命令模式, 用来兼容两种技术栈
2. 对于ES6的语法, 多开技术分享会, 告诉他们这是javascript的趋势, 相信他们能够掌握
3. 从简单的Mobx模型开始, 在实际项目中, 一点一点增加使用复杂度, 自己做一些例子给别人
4. 这点的挑战比较大, 轮岗机制的好处需要长期才能体现出来. 多久轮岗一次, 谁和谁轮岗, 都要技术经理拿捏好

### 开发环境

技术经理的主要职责是提高团队的战斗力. 帮助其他人, 
让他们有一套有高效的开发环境

* 简化开发流程
* 快速编译环境
* 统一的开发配置
* 方便的测试数据

#### 版本管理

* 强制使用git, 明确权限

前端开发 真丶会用 git的人很少, 所以推广git界面工具 SourceTree, 简单易用.
(我再也不用担心后端修改Web前端的代码了).
 
* 将全部项目分成 `PC` 和 `移动` 两个代码库

主要是为了方便管理
(Web前端目前已经超过10个项目), 前端开发人员还不到项目数的一半, 如果分成10个代码库, 管理成本太高.

* 语义化 git 分支

自定义语义化分支
(规范再好也要基于现状, git-flow是个优秀的工作流, 但不适合多项目的web前端)

以移动端为例:

1. 所有移动端项目的开发代码都提交到 master 分支.
2. master分支自动在测试环境部署
3. 测试通过后, 把 master 分支集成到对应的 release-* 分支
4. 推送 release-* 分支, 等待发布

每个项目都有自己的 release-* 分支. 例如 release-wap 分支 release-mall 分支等等.

虽然 单个项目 release-* 分支会包换全部项目的代码, 但是项目之间通过目录进行隔离,
互相之间不会影响, 基于实践, 这种工作流更适合当下环境及业务. 不必拘泥于 git-flow 这种标准工作流.

#### 编译命令 CLI

开发过程中, 采用统一的开发/编译命令

一次性编译页面

> npm run gulp [project]:[page]

监控页面变化, 自动编译新变更

> npm run gulp [project]:[page]:watch

打包/合并代码

> npm run gulp [project]:pack:[page]

添加版本号, 发布到CDN用

> npm run gulp [project]:pack:[page]:revision

辅助命令

> npm run clean // 清理编译结果, 删除 build/dist/cdn 目录

> npm run build:[project] // 完整编译某一个项目的全部页面

> npm run build:[project]:common_js // 编译某一个项目的公共库, 多页面编译时, 节省时间

自定义编译命令的原则

* 统一用法, 底层兼容不同的编译工具 gulp/webpack 等等
* 为 CI 提供统一基础命令
* 方便开发人员使用
* 通过命令为 开发/测试/正式 环境使用不同的编译参数

> npm run gulp [project][:pack]:[page][:watch|revision]

> project   项目名称 wap/mall 等

> pack      测试及正式环境使用, 打包项目

> page      页面名称, 每个项目有多个页面

> watch     开发环境使用, 监控代码变化, 自动重新编译

> revision  给资源添加版本号后缀, 避免静态文件缓存

在开发环境中, 下面2个特性没有使用(Web前端社区非常推崇这2个功能),
但是个人不喜欢, 很难和现有的开发环境集成

* hot reload        禁用热加载
* webpack server    禁用webpack自带server

#### 目录结构

- apps
    - [project a]
        - [page a-1]
        - [page a-2]
    - [project b]
        - [page b-1]
        - [page b-2]
- tasks
    - loaders
    - plugins
    - gulp.config.js
    - webpack.config.js
- gulpfiles
    - gulpfile.[project a].config.js
    - gulpfile.[project b].config.js
- lib
    - [project a]
        - template
        - javascripts
        - images
        - css
    - [project b]
- package.json
- .editrconfig
- .eslintrc
- gulpfile.js


#### 开发服务结构

开发环境的服务配置结构

本机

* 源码 gulp/webpack
* caddy 代理

Web前端代理服务

* nginx 代理

测试环境接口服务

* 多机/多服务

##### 请求数据流向(静态文件)

    HTTP 请求 `fe.[domain].com`
        |
        V
    本机hosts配置
        |
        V
    caddy服务
        |
        V
    `/static/` 路径开头
        |
        V
    指向本机磁盘路径
        |
        V
    [磁盘]:/workspace/repo/project/build/*
        |
        V
    END


##### 请求数据流向(模拟API路径)

    HTTP 请求 `fe.[domain].com`
        |
        V
    本机hosts配置
        |
        V
    caddy服务
        |
        V
    `/fake-api/` 路径开头
        |
        V
    指向本机磁盘路径
        |
        V
    [磁盘]:/workspace/fake-api/project/pathname*
        |
        V
    END

##### 请求数据流向(真实API路径)

    HTTP 请求 `fe.[domain].com`
        |
        V
    本机hosts配置
        |
        V
    caddy服务
        |
        V
    `/api/` 路径开头
        |
        V
    转发至Web前端代理服务
        |
        V
    根据项目名称/域名/API路径 转发到指定IP和端口
        |
        V
    END


#### 公共库

公共库分成两种

* 跨项目公共库
* 项目内公共库

跨项目公共库, 作为基础库, 类似于jQuery, 与特定项目无关. 托管在 npm 上.

项目内公共库, 与特定项目相关, 仅适用当前项目, 在项目内的 `lib` 目录中.

跨项目公共库举例:

    https://www.npmjs.com/package/fw-javascripts

项目内公共库, 可以基于 跨项目公共库创建, 实践中这种方式也十分方便

### 尾声

Web前端的技术革新, 并没有结束. 作为支撑公司业务的技术部门之一, Web前端部门已经组建完成.
可以把此时的Web前端比作一辆刚上路的汽车, 它已经启动并开始前行. 能走多远, 拭目以待.
